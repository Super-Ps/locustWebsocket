{
    "auriga": [
        "compileReq",
        {
            "board": "mega",
            "sources": [
                {
                    "filename": "src/MeEncoderMotorDriverV2.cpp",
                    "code": "/**\r\n * \\par Copyright (C), 2012-2016, MakeBlock\r\n * \\class   MeEncoderMotorDriverV2\r\n * \\brief   Driver for Encoder module.\r\n * @file    MeEncoderMotorDriverV2.cpp\r\n * @author  MakeBlock\r\n * @version V1.0.0\r\n * @date    2017/11/17\r\n * @brief   Driver for Encoder module.\r\n *\r\n * \\par Copyright\r\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \\n\r\n * conditions. The main licensing options available are GPL V2 or Commercial: \\n\r\n *\r\n * \\par Open Source Licensing GPL V2\r\n * This is the appropriate option if you want to share the source code of your \\n\r\n * application with everyone you distribute it to, and you also want to give them \\n\r\n * the right to share who uses it. If you wish to use this software under Open \\n\r\n * Source Licensing, you must contribute all your source code to the open source \\n\r\n * community in accordance with the GPL Version 2 when your application is \\n\r\n * distributed. See http://www.gnu.org/copyleft/gpl.html\r\n *\r\n * \\par Description\r\n * This file is a drive for Encoder.\r\n *\r\n * \\par Method List:\r\n *\r\n *    1. void MeEncoderMotorDriverV2::pwmMove(uint8_t slot);\r\n *\r\n * \\par History:\r\n * <pre>\r\n * \"<Author>\"         \"<Time>\"        \"<Version>\"        \"<Descr>\"\r\n * Payton         2017/12/20     1.0.0            Add description\r\n * </pre>\r\n *\r\n */\r\n\r\n#include \"MeEncoderMotorDriverV2.h\"\r\n\r\n\r\n/**\r\n * Alternate Constructor which can call your own function to map the Encoder Motor New to arduino port,\r\n * you can set any slot for the Encoder Motor New device. \r\n * \\param[in]\r\n *   port - RJ25 port from PORT_1 to PORT_10\r\n * \\param[in]\r\n *   slot - SLOT1 or SLOT2\r\n */\r\nMeEncoderMotorDriverV2::MeEncoderMotorDriverV2(uint8_t addr,uint8_t slot) : MeEncoderNew(addr,slot)\r\n{\r\n\r\n}\r\n\r\n/**\r\n * Alternate Constructor which can call your own function to map the Encoder Motor New to arduino port,\r\n * you can set any slot for the Encoder Motor New device.\r\n * \\param[in]\r\n *   slot - SLOT1 or SLOT2\r\n */\r\nMeEncoderMotorDriverV2::MeEncoderMotorDriverV2(uint8_t slot) : MeEncoderNew(slot)\r\n{\r\n\r\n}\r\n\r\n/**\r\n * Alternate Constructor which can call your own function to map the Encoder Motor New to arduino port,\r\n * you should initialized slot and slaveAddress here for the Encoder Motor New device.\r\n * \\param[in]\r\n *   None\r\n */\r\nMeEncoderMotorDriverV2::MeEncoderMotorDriverV2(void) : MeEncoderNew()\r\n{\r\n\r\n}\r\n\r\n\r\n"
                },
                {
                    "filename": "src/MeEncoderMotorDriverV2.h",
                    "code": "/**\r\n * \\par Copyright (C), 2012-2016, MakeBlock\r\n * \\class   MeEncoderMotorDriverV2\r\n * \\brief   Driver for Encoder module.\r\n * @file    MeEncoderMotorDriverV2.h\r\n * @author  MakeBlock\r\n * @version V1.0.0\r\n * @date    2017/11/17\r\n * @brief   Header for MeEncoderMotorDriverV2.cpp module\r\n *\r\n * \\par Copyright\r\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \\n\r\n * conditions. The main licensing options available are GPL V2 or Commercial: \\n\r\n *\r\n * \\par Open Source Licensing GPL V2\r\n * This is the appropriate option if you want to share the source code of your \\n\r\n * application with everyone you distribute it to, and you also want to give them \\n\r\n * the right to share who uses it. If you wish to use this software under Open \\n\r\n * Source Licensing, you must contribute all your source code to the open source \\n\r\n * community in accordance with the GPL Version 2 when your application is \\n\r\n * distributed. See http://www.gnu.org/copyleft/gpl.html\r\n *\r\n * \\par Description\r\n * This file is a drive for Encoder.\r\n *\r\n * \\par Method List:\r\n *\r\n * \\par History:\r\n * <pre>\r\n * \"<Author>\"         \"<Time>\"        \"<Version>\"        \"<Descr>\"\r\n * Payton        2017/12/20     1.0.0            Build New\r\n * </pre>\r\n */\r\n\r\n#ifndef ME_Encoder_NEW_TEST_H\r\n#define ME_Encoder_NEW_TEST_H\r\n\r\n#include <Arduino.h>\r\n#include <stdbool.h>\r\n#include <avr/interrupt.h>\r\n#include <MeEncoderNew.h>\r\n\r\n\r\n/**\r\n * Class: MeEncoderMotorDriverV2\r\n * \\par Description\r\n * Declaration of Class MeEncoderMotorDriverV2\r\n */\r\nclass MeEncoderMotorDriverV2 : public MeEncoderNew\r\n{\r\npublic:\r\n/**\r\n * Alternate Constructor which can call your own function to map the Encoder Motor New to arduino port,\r\n * you can set any slot for the Encoder Motor New device. \r\n * \\param[in]\r\n *   port - RJ25 port from PORT_1 to PORT_10\r\n * \\param[in]\r\n *   slot - SLOT1 or SLOT2\r\n */\r\n  MeEncoderMotorDriverV2(uint8_t addr,uint8_t slot);\r\n\r\n/**\r\n * Alternate Constructor which can call your own function to map the Encoder Motor New to arduino port,\r\n * you can set any slot for the Encoder Motor New device.\r\n * \\param[in]\r\n *   slot - SLOT1 or SLOT2\r\n */\r\n  MeEncoderMotorDriverV2(uint8_t slot);\r\n\r\n/**\r\n * Alternate Constructor which can call your own function to map the Encoder Motor New to arduino port,\r\n * you should initialized slot and slaveAddress here for the Encoder Motor New device.\r\n * \\param[in]\r\n *   None\r\n */\r\n  MeEncoderMotorDriverV2(void);\r\n\r\n\r\nprivate:\r\n  uint8_t _mode;\r\n\r\n};\r\n#endif\r\n\r\n\r\n\r\n"
                }
            ]
        },
        "// generated by mBlock5 for mBot Ranger\n// codes make you happy\n\n#include <Arduino.h>\n#include <Wire.h>\n#include <SoftwareSerial.h>\n#include <MeAuriga.h>\n\nMeBuzzer buzzer;\nMeLightSensor lightsensor_12(12);\n\nvoid _delay(float seconds) {\n  if(seconds < 0.0){\n    seconds = 0.0;\n  }\n  long endTime = millis() + seconds * 1000;\n  while(millis() < endTime) _loop();\n}\n\nvoid setup() {\n  buzzer.setpin(45);\n  randomSeed((unsigned long)(lightsensor_12.read() * 123456));\n  _delay(1);\n\n  buzzer.tone(262, 0.25 * 1000);\n  _delay(0.02);\n\n}\n\nvoid _loop() {\n}\n\nvoid loop() {\n  _loop();\n}"
    ],
    "mcore": [
        "compileReq",
        {
            "board": "uno",
            "sources": [
                {
                    "filename": "src/demo.cpp",
                    "code": "#include \"demo.h\"\r\nDemoClass::DemoClass(){\r\n\tpinMode(13,OUTPUT);\r\n  level = 0;\r\n}\r\n\r\nvoid DemoClass::blink(){\r\n\tlevel = 1- level;\r\n\tdigitalWrite(13,level);\r\n}"
                },
                {
                    "filename": "src/demo.h",
                    "code": "#ifndef demo_h\r\n#define demo_h\r\n\r\n#include <Arduino.h>\r\n///@brief Class for DemoClass\r\nclass DemoClass\r\n{\r\n\tpublic:\r\n\t\tDemoClass();\r\n\t\tvoid blink();\r\n\tprivate:\r\n\t\tint level;\r\n};\r\n\r\n#endif"
                },
                {
                    "filename": "src/MMA7660.cpp",
                    "code": "/*\n * MMA7760.h\n * Library for accelerometer_MMA7760\n *\n * Copyright (c) 2013 seeed technology inc.\n * Author        :   FrankieChu\n * Create Time   :   Jan 2013\n * Change Log    :\n *\n * The MIT License (MIT)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include <Arduino.h>\n#include <Wire.h>\n#include \"MMA7660.h\"\n\n#define MMA7660TIMEOUT  500         // us\n/*Function: Write a byte to the register of the MMA7660*/\nvoid MMA7660::write(uint8_t _register, uint8_t _data) {\n    Wire.begin();\n    Wire.beginTransmission(MMA7660_ADDR);\n    Wire.write(_register);\n    Wire.write(_data);\n    Wire.endTransmission();\n}\n\n/*Function: Read a byte from the regitster of the MMA7660*/\nuint8_t MMA7660::read(uint8_t _register) {\n    uint8_t data_read;\n    Wire.begin();\n    Wire.beginTransmission(MMA7660_ADDR);\n    Wire.write(_register);\n    Wire.endTransmission();\n    Wire.beginTransmission(MMA7660_ADDR);\n    Wire.requestFrom(MMA7660_ADDR,1);\n    while(Wire.available())\n    {\n        data_read = Wire.read();\n    }\n    Wire.endTransmission();\n    return data_read;\n}\n\n// populate lookup table based on the MMA7660 datasheet at http://www.farnell.com/datasheets/1670762.pdf\nvoid MMA7660::initAccelTable() {\n    int i;\n    float val, valZ;\n\n    for (i = 0, val = 0; i < 32; i++) {\n        accLookup[i].g = val;\n        val += 0.047;\n    }\n\n    for (i = 63, val = -0.047; i > 31; i--) {\n        accLookup[i].g = val;\n        val -= 0.047;\n    }\n\n    for (i = 0, val = 0, valZ = 90; i < 22; i++) {\n        accLookup[i].xyAngle = val;\n        accLookup[i].zAngle = valZ;\n\n        val += 2.69;\n        valZ -= 2.69;\n    }\n\n    for (i = 63, val = -2.69, valZ = -87.31; i > 42; i--) {\n        accLookup[i].xyAngle = val;\n        accLookup[i].zAngle = valZ;\n\n        val -= 2.69;\n        valZ += 2.69;\n    }\n\n    for (i = 22; i < 43; i++) {\n        accLookup[i].xyAngle = 255;\n        accLookup[i].zAngle = 255;\n    }\n}\n\nvoid MMA7660::init()\n{\n    initAccelTable();\n    setMode(MMA7660_STAND_BY);\n    setSampleRate(AUTO_SLEEP_32);\n    setMode(MMA7660_ACTIVE);\n}\n\nvoid MMA7660::init(uint8_t interrupts)\n{\n    initAccelTable();\n    setMode(MMA7660_STAND_BY);\n    setSampleRate(AUTO_SLEEP_32);\n    write(MMA7660_INTSU, interrupts);\n    setMode(MMA7660_ACTIVE);\n}\nvoid MMA7660::setMode(uint8_t mode) {\n    write(MMA7660_MODE,mode);\n}\nvoid MMA7660::setSampleRate(uint8_t rate) {\n    write(MMA7660_SR,rate);\n}\n\n/*Function: Get the contents of the registers in the MMA7660*/\n/*          so as to calculate the acceleration.            */\nbool MMA7660::getXYZ(int8_t *x,int8_t *y,int8_t *z)\n{\n    \nSTART:\n\n    unsigned char val[3];\n    int count = 0;\n    val[0] = val[1] = val[2] = 64;\n    while(Wire.available() > 0)\n    Wire.read();\n\n    Wire.requestFrom(MMA7660_ADDR,3);\n\n    unsigned long timer_s = micros();\n\n    while(Wire.available())\n    {\n        if(count < 3)\n        {\n            while ( val[count] > 63 )  // reload the damn thing it is bad\n            {\n                val[count] = Wire.read();\n\n                if(micros()-timer_s > MMA7660TIMEOUT)\n                {\n                    goto START;\n                }\n            }\n        }\n        count++;\n    }\n\n    *x = ((char)(val[0]<<2))/4;\n    *y = ((char)(val[1]<<2))/4;\n    *z = ((char)(val[2]<<2))/4;\n    \n    return 1;\n}\n\nbool MMA7660::getAcceleration(float *ax,float *ay,float *az)\n{\n    int8_t x,y,z;\n    if(!getXYZ(&x,&y,&z))return 0;\n    *ax = x/21.00;\n    *ay = y/21.00;\n    *az = z/21.00;\n    \n    return 1;\n}\n\nbool MMA7660::getAcceleration(MMA7660_ACC_DATA *data) {\n    unsigned char val[3];\n    int count;\n    bool error;\n\n    unsigned long timer_s = micros();\n    do {\n        error = false;\n        count = 0;\n\n        while(Wire.available() > 0) {\n            Wire.read();\n        }\n\n        Wire.requestFrom(MMA7660_ADDR, 3);\n        while(Wire.available()) {\n            if (count < 3) {\n                val[count] = Wire.read();\n                if (0x40 & val[count] == 0x40) { // alert bit is set, data is garbage and we have to start over.\n                    error = true;\n                    break;\n                }\n            }\n            count++;\n        }\n        \n        if(micros()-timer_s > MMA7660TIMEOUT)return 0;\n    } while (error);\n\n    (*data).x = accLookup[val[0]];\n    (*data).y = accLookup[val[1]];\n    (*data).z = accLookup[val[2]];\n    \n    return 1;\n}\n\nbool MMA7660::getAllData(MMA7660_DATA *data) {\n    int count = 0;\n    uint8_t val[11] = {0};\n\n    while (Wire.available() > 0) {\n        Wire.read();\n    }\n\n    Wire.requestFrom(MMA7660_ADDR, 11);\n    while (Wire.available()) {\n        if (count < 11) {\n            val[count] = Wire.read();\n        }\n        count++;\n    }\n\n    data->X = val[0];\n    data->Y = val[1];\n    data->Z = val[2];\n    data->TILT = val[3];\n    data->SRST = val[4];\n    data->SPCNT = val[5];\n    data->INTSU = val[6];\n    data->MODE = val[7];\n    data->SR = val[8];\n    data->PDET = val[9];\n    data->PD = val[10];\n    \n    return 1;\n}\n"
                },
                {
                    "filename": "src/MMA7660.h",
                    "code": "/*\n * MMA7760.h\n * Library for accelerometer_MMA7760\n *\n * Copyright (c) 2013 seeed technology inc.\n * Author        :   FrankieChu\n * Create Time   :   Jan 2013\n * Change Log    :\n *\n * The MIT License (MIT)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#ifndef __MMC7660_H__\n#define __MMC7660_H__\n\n#define MMA7660_ADDR  0x4c\n\n#define MMA7660_X     0x00\n#define MMA7660_Y     0x01\n#define MMA7660_Z     0x02\n#define MMA7660_TILT  0x03\n#define MMA7660_SRST  0x04\n#define MMA7660_SPCNT 0x05\n#define MMA7660_INTSU 0x06\n  #define MMA7660_SHINTX 0x80\n  #define MMA7660_SHINTY 0x40\n  #define MMA7660_SHINTZ 0x20\n  #define MMA7660_GINT 0x10\n  #define MMA7660_ASINT 0x08\n  #define MMA7660_PDINT 0x04\n  #define MMA7660_PLINT 0x02\n  #define MMA7660_FBINT 0x01\n#define MMA7660_MODE  0x07\n  #define MMA7660_STAND_BY 0x00\n  #define MMA7660_ACTIVE   0x01\n#define MMA7660_SR    0x08      //sample rate register\n  #define AUTO_SLEEP_120  0X00//120 sample per second\n  #define AUTO_SLEEP_64   0X01\n  #define AUTO_SLEEP_32   0X02\n  #define AUTO_SLEEP_16   0X03\n  #define AUTO_SLEEP_8    0X04\n  #define AUTO_SLEEP_4    0X05\n  #define AUTO_SLEEP_2    0X06\n  #define AUTO_SLEEP_1    0X07\n#define MMA7660_PDET  0x09\n#define MMA7660_PD    0x0A\n\nstruct MMA7660_DATA {\n  uint8_t X;\n  uint8_t Y;\n  uint8_t Z;\n  uint8_t TILT;\n  uint8_t SRST;\n  uint8_t SPCNT;\n  uint8_t INTSU;\n  uint8_t MODE;\n  uint8_t SR;\n  uint8_t PDET;\n  uint8_t PD;\n};\n\nstruct MMA7660_LOOKUP {\n  float g;\n  float xyAngle;\n  float zAngle;\n};\n\nstruct MMA7660_ACC_DATA {\n  MMA7660_LOOKUP x;\n  MMA7660_LOOKUP y;\n  MMA7660_LOOKUP z;\n};\n\nclass MMA7660 {\nprivate:\n  void write(uint8_t _register, uint8_t _data);\n  uint8_t read(uint8_t _register);\n  void initAccelTable();\n\n  MMA7660_LOOKUP accLookup[64];\n\npublic:\n  void init();\n  void init(uint8_t interrupts);\n  void setMode(uint8_t mode);\n  void setSampleRate(uint8_t rate);\n\n  // get the signed value of x,y,z register\n  bool getXYZ(int8_t *x,int8_t *y,int8_t *z);\n\n  // calculate the acceleration from the signed value of x,y,z register\n  bool getAcceleration(float *ax,float *ay,float *az);\n\n  // lookup the acceleration from the lookup table from this chip's datasheet\n  bool getAcceleration(MMA7660_ACC_DATA *data);\n\n  // get all the register value\n  bool getAllData(MMA7660_DATA *data);\n};\n\n#endif\n"
                },
                {
                    "filename": "src/rgb_lcd.cpp",
                    "code": "/*\n  rgb_lcd.cpp\n  2013 Copyright (c) Seeed Technology Inc.  All right reserved.\n\n  Author:Loovee\n  2013-9-18\n\n  add rgb backlight fucnction @ 2013-10-15\n  \n  The MIT License (MIT)\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.1  USA\n*/\n\n#include <Arduino.h>\n#include <stdio.h>\n#include <string.h>\n#include <inttypes.h>\n#include <Wire.h>\n\n#include \"rgb_lcd.h\"\n\nvoid i2c_send_byte(unsigned char dta)\n{\n    Wire.beginTransmission(LCD_ADDRESS);        // transmit to device #4\n    Wire.write(dta);                            // sends five bytes\n    Wire.endTransmission();                     // stop transmitting\n}\n\nvoid i2c_send_byteS(unsigned char *dta, unsigned char len)\n{\n    Wire.beginTransmission(LCD_ADDRESS);        // transmit to device #4\n    for(int i=0; i<len; i++)\n    {\n        Wire.write(dta[i]);\n    }\n    Wire.endTransmission();                     // stop transmitting\n}\n\nrgb_lcd::rgb_lcd()\n{\n}\n\nvoid rgb_lcd::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) \n{\n\n    Wire.begin();\n    \n    if (lines > 1) {\n        _displayfunction |= LCD_2LINE;\n    }\n    _numlines = lines;\n    _currline = 0;\n\n    // for some 1 line displays you can select a 10 pixel high font\n    if ((dotsize != 0) && (lines == 1)) {\n        _displayfunction |= LCD_5x10DOTS;\n    }\n\n    // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!\n    // according to datasheet, we need at least 40ms after power rises above 2.7V\n    // before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50\n    delayMicroseconds(50000);\n\n\n    // this is according to the hitachi HD44780 datasheet\n    // page 45 figure 23\n\n    // Send function set command sequence\n    command(LCD_FUNCTIONSET | _displayfunction);\n    delayMicroseconds(4500);  // wait more than 4.1ms\n\n    // second try\n    command(LCD_FUNCTIONSET | _displayfunction);\n    delayMicroseconds(150);\n\n    // third go\n    command(LCD_FUNCTIONSET | _displayfunction);\n\n\n    // finally, set # lines, font size, etc.\n    command(LCD_FUNCTIONSET | _displayfunction);\n\n    // turn the display on with no cursor or blinking default\n    _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;\n    display();\n\n    // clear it off\n    clear();\n\n    // Initialize to default text direction (for romance languages)\n    _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;\n    // set the entry mode\n    command(LCD_ENTRYMODESET | _displaymode);\n    \n    \n    // backlight init\n    setReg(REG_MODE1, 0);\n    // set LEDs controllable by both PWM and GRPPWM registers\n    setReg(REG_OUTPUT, 0xFF);\n    // set MODE2 values\n    // 0010 0000 -> 0x20  (DMBLNK to 1, ie blinky mode)\n    setReg(REG_MODE2, 0x20);\n    \n    setColorWhite();\n\n}\n\n/********** high level commands, for the user! */\nvoid rgb_lcd::clear()\n{\n    command(LCD_CLEARDISPLAY);        // clear display, set cursor position to zero\n    delayMicroseconds(2000);          // this command takes a long time!\n}\n\nvoid rgb_lcd::home()\n{\n    command(LCD_RETURNHOME);        // set cursor position to zero\n    delayMicroseconds(2000);        // this command takes a long time!\n}\n\nvoid rgb_lcd::setCursor(uint8_t col, uint8_t row)\n{\n\n    col = (row == 0 ? col|0x80 : col|0xc0);\n    unsigned char dta[2] = {0x80, col};\n\n    i2c_send_byteS(dta, 2);\n\n}\n\n// Turn the display on/off (quickly)\nvoid rgb_lcd::noDisplay()\n{\n    _displaycontrol &= ~LCD_DISPLAYON;\n    command(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\nvoid rgb_lcd::display() {\n    _displaycontrol |= LCD_DISPLAYON;\n    command(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// Turns the underline cursor on/off\nvoid rgb_lcd::noCursor()\n{\n    _displaycontrol &= ~LCD_CURSORON;\n    command(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\nvoid rgb_lcd::cursor() {\n    _displaycontrol |= LCD_CURSORON;\n    command(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// Turn on and off the blinking cursor\nvoid rgb_lcd::noBlink()\n{\n    _displaycontrol &= ~LCD_BLINKON;\n    command(LCD_DISPLAYCONTROL | _displaycontrol);\n}\nvoid rgb_lcd::blink()\n{\n    _displaycontrol |= LCD_BLINKON;\n    command(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// These commands scroll the display without changing the RAM\nvoid rgb_lcd::scrollDisplayLeft(void)\n{\n    command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);\n}\nvoid rgb_lcd::scrollDisplayRight(void)\n{\n    command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);\n}\n\n// This is for text that flows Left to Right\nvoid rgb_lcd::leftToRight(void)\n{\n    _displaymode |= LCD_ENTRYLEFT;\n    command(LCD_ENTRYMODESET | _displaymode);\n}\n\n// This is for text that flows Right to Left\nvoid rgb_lcd::rightToLeft(void)\n{\n    _displaymode &= ~LCD_ENTRYLEFT;\n    command(LCD_ENTRYMODESET | _displaymode);\n}\n\n// This will 'right justify' text from the cursor\nvoid rgb_lcd::autoscroll(void)\n{\n    _displaymode |= LCD_ENTRYSHIFTINCREMENT;\n    command(LCD_ENTRYMODESET | _displaymode);\n}\n\n// This will 'left justify' text from the cursor\nvoid rgb_lcd::noAutoscroll(void)\n{\n    _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;\n    command(LCD_ENTRYMODESET | _displaymode);\n}\n\n// Allows us to fill the first 8 CGRAM locations\n// with custom characters\nvoid rgb_lcd::createChar(uint8_t location, uint8_t charmap[])\n{\n\n    location &= 0x7; // we only have 8 locations 0-7\n    command(LCD_SETCGRAMADDR | (location << 3));\n    \n    \n    unsigned char dta[9];\n    dta[0] = 0x40;\n    for(int i=0; i<8; i++)\n    {\n        dta[i+1] = charmap[i];\n    }\n    i2c_send_byteS(dta, 9);\n}\n\n// Control the backlight LED blinking\nvoid rgb_lcd::blinkLED(void)\n{\n    // blink period in seconds = (<reg 7> + 1) / 24\n    // on/off ratio = <reg 6> / 256\n    setReg(0x07, 0x17);  // blink every second\n    setReg(0x06, 0x7f);  // half on, half off\n}\n\nvoid rgb_lcd::noBlinkLED(void)\n{\n    setReg(0x07, 0x00);\n    setReg(0x06, 0xff);\n}\n\n/*********** mid level commands, for sending data/cmds */\n\n// send command\ninline void rgb_lcd::command(uint8_t value)\n{\n    unsigned char dta[2] = {0x80, value};\n    i2c_send_byteS(dta, 2);\n}\n\n// send data\ninline size_t rgb_lcd::write(uint8_t value)\n{\n\n    unsigned char dta[2] = {0x40, value};\n    i2c_send_byteS(dta, 2);\n    return 1; // assume sucess\n}\n\nvoid rgb_lcd::setReg(unsigned char addr, unsigned char dta)\n{\n    Wire.beginTransmission(RGB_ADDRESS); // transmit to device #4\n    Wire.write(addr);\n    Wire.write(dta);\n    Wire.endTransmission();    // stop transmitting\n}\n\nvoid rgb_lcd::setRGB(unsigned char r, unsigned char g, unsigned char b)\n{\n    setReg(REG_RED, r);\n    setReg(REG_GREEN, g);\n    setReg(REG_BLUE, b);\n}\n\nconst unsigned char color_define[4][3] = \n{\n    {255, 255, 255},            // white\n    {255, 0, 0},                // red\n    {0, 255, 0},                // green\n    {0, 0, 255},                // blue\n};\n\nvoid rgb_lcd::setColor(unsigned char color)\n{\n    if(color > 3)return ;\n    setRGB(color_define[color][0], color_define[color][1], color_define[color][2]);\n}\n"
                },
                {
                    "filename": "src/rgb_lcd.h",
                    "code": "/*\n  rgb_lcd.h\n  2013 Copyright (c) Seeed Technology Inc.  All right reserved.\n\n  Author:Loovee\n  2013-9-18\n\n  add rgb backlight fucnction @ 2013-10-15\n  \n  The MIT License (MIT)\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.1  USA\n*/\n\n\n#ifndef __RGB_LCD_H__\n#define __RGB_LCD_H__\n\n#include <inttypes.h>\n#include \"Print.h\"\n\n// Device I2C Arress\n#define LCD_ADDRESS     (0x7c>>1)\n#define RGB_ADDRESS     (0xc4>>1)\n\n\n// color define \n#define WHITE           0\n#define RED             1\n#define GREEN           2\n#define BLUE            3\n\n#define REG_RED         0x04        // pwm2\n#define REG_GREEN       0x03        // pwm1\n#define REG_BLUE        0x02        // pwm0\n\n#define REG_MODE1       0x00\n#define REG_MODE2       0x01\n#define REG_OUTPUT      0x08\n\n// commands\n#define LCD_CLEARDISPLAY 0x01\n#define LCD_RETURNHOME 0x02\n#define LCD_ENTRYMODESET 0x04\n#define LCD_DISPLAYCONTROL 0x08\n#define LCD_CURSORSHIFT 0x10\n#define LCD_FUNCTIONSET 0x20\n#define LCD_SETCGRAMADDR 0x40\n#define LCD_SETDDRAMADDR 0x80\n\n// flags for display entry mode\n#define LCD_ENTRYRIGHT 0x00\n#define LCD_ENTRYLEFT 0x02\n#define LCD_ENTRYSHIFTINCREMENT 0x01\n#define LCD_ENTRYSHIFTDECREMENT 0x00\n\n// flags for display on/off control\n#define LCD_DISPLAYON 0x04\n#define LCD_DISPLAYOFF 0x00\n#define LCD_CURSORON 0x02\n#define LCD_CURSOROFF 0x00\n#define LCD_BLINKON 0x01\n#define LCD_BLINKOFF 0x00\n\n// flags for display/cursor shift\n#define LCD_DISPLAYMOVE 0x08\n#define LCD_CURSORMOVE 0x00\n#define LCD_MOVERIGHT 0x04\n#define LCD_MOVELEFT 0x00\n\n// flags for function set\n#define LCD_8BITMODE 0x10\n#define LCD_4BITMODE 0x00\n#define LCD_2LINE 0x08\n#define LCD_1LINE 0x00\n#define LCD_5x10DOTS 0x04\n#define LCD_5x8DOTS 0x00\n\nclass rgb_lcd : public Print \n{\n\npublic:\n  rgb_lcd();\n\n  void begin(uint8_t cols, uint8_t rows, uint8_t charsize = LCD_5x8DOTS);\n\n  void clear();\n  void home();\n\n  void noDisplay();\n  void display();\n  void noBlink();\n  void blink();\n  void noCursor();\n  void cursor();\n  void scrollDisplayLeft();\n  void scrollDisplayRight();\n  void leftToRight();\n  void rightToLeft();\n  void autoscroll();\n  void noAutoscroll();\n\n  void createChar(uint8_t, uint8_t[]);\n  void setCursor(uint8_t, uint8_t); \n  \n  virtual size_t write(uint8_t);\n  void command(uint8_t);\n  \n  // color control\n  void setRGB(unsigned char r, unsigned char g, unsigned char b);               // set rgb\n  void setPWM(unsigned char color, unsigned char pwm){setReg(color, pwm);}      // set pwm\n  \n  void setColor(unsigned char color);\n  void setColorAll(){setRGB(0, 0, 0);}\n  void setColorWhite(){setRGB(255, 255, 255);}\n\n  // blink the LED backlight\n  void blinkLED(void);\n  void noBlinkLED(void);\n  \n  using Print::write;\n  \nprivate:\n  void send(uint8_t, uint8_t);\n  void setReg(unsigned char addr, unsigned char dta);\n\n  uint8_t _displayfunction;\n  uint8_t _displaycontrol;\n  uint8_t _displaymode;\n\n  uint8_t _initialized;\n\n  uint8_t _numlines,_currline;\n};\n\n#endif\n"
                }
            ]
        },
        "// generated by mBlock5 for mBot\n// codes make you happy\n\n#include <MeMCore.h>\n#include <Arduino.h>\n#include <Wire.h>\n#include <SoftwareSerial.h>\n\nMeBuzzer buzzer;\n\nvoid __delay(float seconds) {\n  long endTime = millis() + seconds * 1000;\n  while(millis() < endTime) _loop();\n}\n\nvoid setup() {\n  _delay(1);\n  buzzer.tone(262, 0.25 * 1000);\n  delay(20);\n\n}\n\nvoid _loop() {\n}\n\nvoid loop() {\n  _loop();\n}\n\n"
    ]
}
